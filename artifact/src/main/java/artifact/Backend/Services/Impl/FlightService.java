package artifact.Backend.Services.Impl;
import artifact.Backend.Models.Airport;
import artifact.Backend.Models.Flight;
import artifact.Backend.Models.FlightSearchResult;
import artifact.Backend.Models.DTO.FlightRequest;
import artifact.Backend.Models.ServiceResult;
import artifact.Backend.Repositories.Interfaces.IAircraftRepository;
import artifact.Backend.Repositories.Interfaces.IAirportRepository;
import artifact.Backend.Repositories.Interfaces.IFlightRepository;
import artifact.Backend.Services.Interfaces.IFlightService;

import java.time.LocalDate;
import java.time.YearMonth;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Service implementation for managing Flight operations.
 * Handles the creation of flights, validating routes, and searching for available flights.
 */
public class FlightService implements IFlightService {

    private final IFlightRepository flightRepository;
    private final IAircraftRepository aircraftRepository;
    private final IAirportRepository airportRepository;

    /**
     * Dependency Injection constructor.
     *
     * @param flight   Repository for flight persistence.
     * @param aircraft Repository for aircraft data.
     * @param airport  Repository for airport data.
     */
    public FlightService(IFlightRepository flight, IAircraftRepository aircraft, IAirportRepository airport) {
        this.flightRepository = flight;
        this.aircraftRepository = aircraft;
        this.airportRepository = airport;
    }

    /**
     * Validates and adds a new flight to the system.
     *
     * @param request The DTO containing flight details (airports, crew, aircraft, dates).
     * @return ServiceResult indicating success or containing specific validation errors.
     */
    @Override
    public ServiceResult addFlight(FlightRequest request) {
        ServiceResult result = new ServiceResult();

        // 1. Field Validation: Ensure no required fields are null
        if (request.depAirport() == null) result.addError("depAirport", "Departure airport must be selected*");
        if (request.arrAirport() == null) result.addError("arrAirport", "Arrival airport must be selected*");
        if (request.aircraft() == null) result.addError("aircraft", "Aircraft must be selected*");
        if (request.crew() == null) result.addError("crew", "Crew must be selected*");
        if (request.depDate() == null) result.addError("depDate", "Departure date is required*");
        if (request.arrDate() == null) result.addError("arrDate", "Arrival date is required*");

        // 2. Logical Validation: Check for impossible routes or dates
        if (request.depAirport() != null && request.arrAirport() != null 
            && request.depAirport().id() == request.arrAirport().id()) {
            result.setGlobalError("Departure and Arrival airports cannot be the same.");
        }
        
        if (request.depDate() != null && request.arrDate() != null 
            && request.arrDate().isBefore(request.depDate())) {
            result.setGlobalError("Arrival date cannot be before departure date.");
        }

        // Return immediately if validation fails to prevent partial processing
        if (!result.isSuccess()) return result;

        // 3. Business Logic: Retrieve aircraft capacity and persist the flight
        int capacity = aircraftRepository.findById(request.aircraft().id()).capacity();
        
        flightRepository.add(new Flight(
            0, // ID auto-generated by repository
            request.depAirport().id(), 
            request.arrAirport().id(), 
            request.aircraft().id(), 
            request.crew().id(), 
            request.depDate(), 
            request.arrDate(), 
            capacity
        ));
        
        return result;
    }

    /**
     * Retrieves all dates within a specific month that have flights for a given route.
     * Used for populating calendars in the UI.
     *
     * @param from  Departure Airport.
     * @param to    Arrival Airport.
     * @param month The month to check.
     * @return A Set of LocalDates representing days with available flights.
     */
    @Override
    public Set<LocalDate> getAvailableFlightDates(Airport from, Airport to, YearMonth month) {
        if (from == null || to == null) return Collections.emptySet();
        
        // Fetch flights matching route and month, then map to their departure dates
        return flightRepository.findFlightsByRouteAndMonth(from.id(), to.id(), month).stream()
            .map(Flight::departureTime)
            .collect(Collectors.toSet());
    }

    /**
     * Searches for flights matching a specific route and date with available seats.
     *
     * @param from Departure Airport.
     * @param to   Arrival Airport.
     * @param date Date of departure.
     * @return A list of FlightSearchResult DTOs containing full object details (Airport/Aircraft objects).
     */
    @Override
    public List<FlightSearchResult> searchFlights(Airport from, Airport to, LocalDate date) {
        // Filter the repository for exact matches with > 0 seats
        List<Flight> matchingFlights = flightRepository.getAll().stream()
            .filter(f -> f.departureAirportId() == from.id())
            .filter(f -> f.arrivalAirportId() == to.id())
            .filter(f -> f.departureTime().isEqual(date))
            .filter(f -> f.availableSeats() > 0)
            .collect(Collectors.toList());
        
        // Enrich the Flight entities with related objects (Join-like behavior) for the UI
        return matchingFlights.stream()
            .map(flight -> new FlightSearchResult(
                flight,
                airportRepository.findById(flight.departureAirportId()),
                airportRepository.findById(flight.arrivalAirportId()),
                aircraftRepository.findById(flight.aircraftId())
            ))
            .collect(Collectors.toList());
    }
}